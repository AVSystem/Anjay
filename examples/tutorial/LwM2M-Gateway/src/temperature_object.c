/**
 * Generated by anjay_codegen.py on 2024-10-03 12:40:55
 *
 * LwM2M Object: Temperature
 * ID: 3303, URN: urn:oma:lwm2m:ext:3303:1.1, Optional, Multiple
 *
 * This IPSO object should be used with a temperature sensor to report a
 * temperature measurement.  It also provides resources for
 * minimum/maximum measured values and the minimum/maximum range that can
 * be measured by the temperature sensor. An example measurement unit is
 * degrees Celsius.
 */
#include <assert.h>
#include <stdbool.h>

#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_list.h>
#include <avsystem/commons/avs_log.h>
#include <avsystem/commons/avs_memory.h>

#include <anjay/anjay.h>
#include <anjay/dm.h>
#include <anjay/lwm2m_gateway.h>
#include <anjay/lwm2m_send.h>

#include "gateway_server.h"
#include "temperature_object.h"

#define CACHE_VALID_PERIOD_S 3

#define OID_TEMPERATURE 3303

/**
 * Min Measured Value: R, Single, Optional
 * type: float, range: N/A, unit: N/A
 * The minimum value measured by the sensor since power ON or reset.
 */
#define RID_MIN_MEASURED_VALUE 5601

/**
 * Max Measured Value: R, Single, Optional
 * type: float, range: N/A, unit: N/A
 * The maximum value measured by the sensor since power ON or reset.
 */
#define RID_MAX_MEASURED_VALUE 5602

/**
 * Reset Min and Max Measured Values: E, Single, Optional
 * type: N/A, range: N/A, unit: N/A
 * Reset the Min and Max Measured Values to Current Value.
 */
#define RID_RESET_MIN_AND_MAX_MEASURED_VALUES 5605

/**
 * Sensor Value: R, Single, Mandatory
 * type: float, range: N/A, unit: N/A
 * Last or Current Measured Value from the Sensor.
 */
#define RID_SENSOR_VALUE 5700

/**
 * Application Type: RW, Single, Optional
 * type: string, range: N/A, unit: N/A
 * The application type of the sensor or actuator as a string depending
 * on the use case.
 */
#define RID_APPLICATION_TYPE 5750

typedef struct cached_value_struct {
    double value;
    avs_time_monotonic_t timestamp;
} cached_value_t;

typedef struct temperature_instance_struct {
    anjay_iid_t iid;

    char application_type[10];
    char application_type_backup[10];

    cached_value_t max_meas_cached_value;
    cached_value_t min_meas_cached_value;
    cached_value_t sensor_meas_cached_value;
} temperature_instance_t;

typedef struct temperature_object_struct {
    const anjay_dm_object_def_t *def;
    temperature_instance_t instances[1];
    gateway_srv_t *gateway_srv;
    anjay_iid_t end_device_iid;
} temperature_object_t;

static gateway_request_type_t rid_to_request_type(anjay_rid_t rid) {
    switch (rid) {
    case RID_MIN_MEASURED_VALUE:
        return GATEWAY_REQUEST_TYPE_GET_MIN_MEASURED_VALUE;
    case RID_MAX_MEASURED_VALUE:
        return GATEWAY_REQUEST_TYPE_GET_MAX_MEASURED_VALUE;
    case RID_SENSOR_VALUE:
        return GATEWAY_REQUEST_TYPE_GET_TEMPERATURE;
    default:
        return -1;
    }
}

static cached_value_t *rid_to_cached_value(temperature_instance_t *inst,
                                           anjay_rid_t rid) {
    switch (rid) {
    case RID_MIN_MEASURED_VALUE:
        return &inst->min_meas_cached_value;
    case RID_MAX_MEASURED_VALUE:
        return &inst->max_meas_cached_value;
    case RID_SENSOR_VALUE:
        return &inst->sensor_meas_cached_value;
    default:
        return NULL;
    }
}

static inline temperature_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, temperature_object_t, def);
}

static int list_instances(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_dm_list_ctx_t *ctx) {
    (void) anjay;

    temperature_object_t *obj = get_obj(obj_ptr);
    for (anjay_iid_t iid = 0; iid < AVS_ARRAY_SIZE(obj->instances); iid++) {
        anjay_dm_emit(ctx, iid);
    }

    return 0;
}

static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;

    temperature_object_t *obj = get_obj(obj_ptr);
    assert(iid < AVS_ARRAY_SIZE(obj->instances));
    temperature_instance_t *inst = &obj->instances[iid];

    inst->application_type[0] = '\0';
    return 0;
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_MIN_MEASURED_VALUE, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_MAX_MEASURED_VALUE, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_RESET_MIN_AND_MAX_MEASURED_VALUES,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_SENSOR_VALUE, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_APPLICATION_TYPE, ANJAY_DM_RES_RW,
                      ANJAY_DM_RES_PRESENT);
    return 0;
}

static int get_eid_resource_value(temperature_object_t *obj,
                                  anjay_rid_t rid,
                                  cached_value_t *cached_value,
                                  bool force_update) {
    avs_time_monotonic_t current_time = avs_time_monotonic_now();

    if (!force_update) {
        int64_t diff;
        if (avs_time_duration_to_scalar(
                    &diff, AVS_TIME_S,
                    avs_time_monotonic_diff(current_time,
                                            cached_value->timestamp))) {
            return ANJAY_ERR_INTERNAL;
        }

        if (diff < CACHE_VALID_PERIOD_S) {
            return 0;
        }
    }
    int res;
    char buffer[VALUE_MESSAGE_MAX_LEN];
    if ((res = gateway_request(obj->gateway_srv, obj->end_device_iid,
                               rid_to_request_type(rid), buffer,
                               VALUE_MESSAGE_MAX_LEN))) {
        return res;
    }

    cached_value->value = atof(buffer);
    cached_value->timestamp = current_time;
    return 0;
}

static void update_resource(anjay_t *anjay,
                            temperature_object_t *obj,
                            temperature_instance_t *inst,
                            anjay_rid_t rid) {
    anjay_resource_observation_status_t status =
            anjay_lwm2m_gateway_resource_observation_status(anjay,
                                                            obj->end_device_iid,
                                                            OID_TEMPERATURE,
                                                            inst->iid, rid);
    if (status.is_observed) {
        cached_value_t *cached_value = rid_to_cached_value(inst, rid);
        double prev_value = cached_value->value;
        get_eid_resource_value(obj, rid, cached_value, true);

        if (prev_value != cached_value->value) {
            anjay_lwm2m_gateway_notify_changed(anjay, obj->end_device_iid,
                                               OID_TEMPERATURE, inst->iid, rid);
        }
    }
}

static void evaluation_period_update_value(anjay_t *anjay,
                                           temperature_object_t *obj,
                                           temperature_instance_t *inst,
                                           anjay_rid_t rid,
                                           int32_t *max_evaluation_period) {
    anjay_resource_observation_status_t status =
            anjay_lwm2m_gateway_resource_observation_status(anjay,
                                                            obj->end_device_iid,
                                                            OID_TEMPERATURE,
                                                            inst->iid, rid);

    if (status.is_observed && status.max_eval_period != ANJAY_ATTRIB_PERIOD_NONE
            && *max_evaluation_period > status.max_eval_period) {
        *max_evaluation_period = status.max_eval_period;
    }
}

void temperature_object_evaluation_period_update_value(
        anjay_t *anjay,
        const anjay_dm_object_def_t **def,
        int32_t *evaluation_period) {
    assert(anjay);
    temperature_object_t *obj = get_obj(def);

    for (size_t iid = 0; iid < AVS_ARRAY_SIZE(obj->instances); iid++) {
        evaluation_period_update_value(anjay, obj, &obj->instances[iid],
                                       RID_MIN_MEASURED_VALUE,
                                       evaluation_period);
        evaluation_period_update_value(anjay, obj, &obj->instances[iid],
                                       RID_MAX_MEASURED_VALUE,
                                       evaluation_period);
        evaluation_period_update_value(anjay, obj, &obj->instances[iid],
                                       RID_SENSOR_VALUE, evaluation_period);
    }
}

void temperature_object_update_value(anjay_t *anjay,
                                     const anjay_dm_object_def_t **def) {
    assert(anjay);
    temperature_object_t *obj = get_obj(def);

    for (size_t iid = 0; iid < AVS_ARRAY_SIZE(obj->instances); iid++) {
        update_resource(anjay, obj, &obj->instances[iid],
                        RID_MIN_MEASURED_VALUE);
        update_resource(anjay, obj, &obj->instances[iid],
                        RID_MAX_MEASURED_VALUE);
        update_resource(anjay, obj, &obj->instances[iid], RID_SENSOR_VALUE);
    }
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;
    assert(riid == ANJAY_ID_INVALID);

    temperature_object_t *obj = get_obj(obj_ptr);
    assert(iid < AVS_ARRAY_SIZE(obj->instances));
    temperature_instance_t *inst = &obj->instances[iid];
    int res;

    switch (rid) {
    case RID_MIN_MEASURED_VALUE:
    case RID_MAX_MEASURED_VALUE:
    case RID_SENSOR_VALUE: {
        cached_value_t *cached_value = rid_to_cached_value(inst, rid);
        res = get_eid_resource_value(obj, rid, cached_value, false);
        return res ? ANJAY_ERR_INTERNAL
                   : anjay_ret_double(ctx, cached_value->value);
    }
    case RID_APPLICATION_TYPE:
        return anjay_ret_string(ctx, inst->application_type);

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_write(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_rid_t rid,
                          anjay_riid_t riid,
                          anjay_input_ctx_t *ctx) {
    (void) anjay;

    temperature_object_t *obj = get_obj(obj_ptr);
    assert(iid < AVS_ARRAY_SIZE(obj->instances));
    temperature_instance_t *inst = &obj->instances[iid];

    switch (rid) {
    case RID_APPLICATION_TYPE: {
        assert(riid == ANJAY_ID_INVALID);
        return anjay_get_string(ctx, inst->application_type,
                                sizeof(inst->application_type));
    }

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_execute(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_execute_ctx_t *arg_ctx) {
    (void) anjay;
    (void) arg_ctx;

    temperature_object_t *obj = get_obj(obj_ptr);
    assert(iid < AVS_ARRAY_SIZE(obj->instances));
    char buffer[EXECUTE_MSG_RESPONSE_LEN];

    switch (rid) {
    case RID_RESET_MIN_AND_MAX_MEASURED_VALUES:
        return gateway_request(
                obj->gateway_srv, obj->end_device_iid,
                GATEWAY_REQUEST_TYPE_RESET_MIN_AND_MAX_MEASURED_VALUES, buffer,
                EXECUTE_MSG_RESPONSE_LEN);

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int transaction_begin(anjay_t *anjay,
                             const anjay_dm_object_def_t *const *obj_ptr) {
    (void) anjay;

    temperature_object_t *obj = get_obj(obj_ptr);
    temperature_instance_t *inst = &obj->instances[0];
    strcpy(inst->application_type_backup, inst->application_type);

    return 0;
}

static int transaction_rollback(anjay_t *anjay,
                                const anjay_dm_object_def_t *const *obj_ptr) {
    (void) anjay;

    temperature_object_t *obj = get_obj(obj_ptr);
    temperature_instance_t *inst = &obj->instances[0];
    strcpy(inst->application_type, inst->application_type_backup);

    return 0;
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = OID_TEMPERATURE,
    .version = "1.1",
    .handlers = {
        .list_instances = list_instances,
        .instance_reset = instance_reset,

        .list_resources = list_resources,
        .resource_read = resource_read,
        .resource_write = resource_write,
        .resource_execute = resource_execute,

        .transaction_begin = transaction_begin,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = transaction_rollback
    }
};

const anjay_dm_object_def_t **
temperature_object_create(int id, gateway_srv_t *gateway_srv) {
    temperature_object_t *obj =
            (temperature_object_t *) avs_calloc(1,
                                                sizeof(temperature_object_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    sprintf(obj->instances[0].application_type, "Sensor %d", id);
    obj->end_device_iid = id;
    obj->gateway_srv = gateway_srv;

    return &obj->def;
}

void temperature_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        temperature_object_t *obj = get_obj(def);
        avs_free(obj);
    }
}

static void send_finished_handler(anjay_t *anjay,
                                  anjay_ssid_t ssid,
                                  const anjay_send_batch_t *batch,
                                  int result,
                                  void *data) {
    (void) anjay;
    (void) ssid;
    (void) batch;
    (void) data;
    if (result != ANJAY_SEND_SUCCESS) {
        avs_log(temperature_object, ERROR, "Send failed, result: %d", result);
    } else {
        avs_log(temperature_object, INFO, "Send successful");
    }
}

void temperature_object_send(anjay_t *anjay,
                             AVS_LIST(end_device_t) end_devices) {
    if (!anjay) {
        return;
    }
    const anjay_ssid_t server_ssid = 1;

    if (!end_devices) {
        avs_log(temperature_object, TRACE,
                "No end devices found, skipping sending data");
        return;
    }

    // Allocate new batch builder.
    anjay_send_batch_builder_t *builder = anjay_send_batch_builder_new();
    if (!builder) {
        avs_log(temperature_object, ERROR, "Failed to allocate batch builder");
        return;
    }

    AVS_LIST(end_device_t) it;
    AVS_LIST_FOREACH(it, end_devices) {
        // Add current values of resource from Temperature Object.
        temperature_object_t *obj = get_obj(it->temperature_object);
        temperature_instance_t *inst = &obj->instances[0];
        if (anjay_lwm2m_gateway_send_batch_data_add_current(
                    builder, anjay, obj->end_device_iid, obj->def->oid,
                    inst->iid, RID_SENSOR_VALUE)) {
            anjay_send_batch_builder_cleanup(&builder);
            avs_log(temperature_object, ERROR, "Failed to add batch data");
            return;
        }
    }

    // After adding all values, compile our batch for sending.
    anjay_send_batch_t *batch = anjay_send_batch_builder_compile(&builder);
    if (!batch) {
        anjay_send_batch_builder_cleanup(&builder);
        avs_log(temperature_object, ERROR, "Batch compile failed");
        return;
    }

    // Schedule our send to be run on next `anjay_sched_run()` call.
    int res =
            anjay_send(anjay, server_ssid, batch, send_finished_handler, NULL);
    if (res) {
        avs_log(temperature_object, ERROR, "Failed to send, result: %d", res);
    }

    // After scheduling, we can release our batch.
    anjay_send_batch_release(&batch);
}
