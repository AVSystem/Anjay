..
   Copyright 2017-2019 AVSystem <avsystem@avsystem.com>

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

Tools
=====

.. _anjay-object-stub-generator:

Anjay Object stub generator
---------------------------

For easy implementation of custom objects, you can use the
`./tools/anjay_codegen.py` script. It parses an LwM2M Object Definition XML
and generates a skeleton of the LwM2M object code, requiring the user to only
fill in actual object logic.

You can use `./tools/lwm2m_object_registry.py` script to download the
Object Definition XML from `OMA LwM2M Object and Resource Registry
<http://www.openmobilealliance.org/wp/OMNA/LwM2M/LwM2MRegistry.html>`_.

Usage examples
~~~~~~~~~~~~~~

.. code-block:: bash

    # list registered LwM2M objects
    ./tools/lwm2m_object_registry.py --list

    # download Object Definition XML for object 3 (Device) to device.xml
    ./tools/lwm2m_object_registry.py --get-xml 3 > device.xml

    # generate object code stub from device.xml
    ./tools/anjay_codegen.py -i device.xml -o device.c

    # download Object Defintion XML for object 3 and generate code stub
    # without creating an intermediate file
    ./tools/lwm2m_object_registry.py --get-xml 3 | ./tools/anjay_codegen.py -i - -o device.c


Output example
~~~~~~~~~~~~~~

Consider the following xml Object definition:

.. code-block:: xml

    <?xml version="1.0" encoding="utf-8"?>
    <LWM2M xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://openmobilealliance.org/tech/profiles/LWM2M.xsd">
      <Object ObjectType="MODefinition">
            <Name>Some Object Name</Name>
            <Description1><![CDATA[LwM2M Object description.]]></Description1>
            <ObjectID>9999</ObjectID>
            <ObjectURN></ObjectURN>
            <MultipleInstances>Multiple</MultipleInstances>
            <Mandatory>Optional</Mandatory>
            <Resources>
                <Item ID="0">
                    <Name>Some String Resource</Name>
                    <Operations>RW</Operations>
                    <MultipleInstances>Single</MultipleInstances>
                    <Mandatory>Mandatory</Mandatory>
                    <Type>String</Type>
                    <RangeEnumeration></RangeEnumeration>
                    <Units></Units>
                    <Description><![CDATA[Some description.]]></Description>
                </Item>
                <Item ID="1">
                    <Name>Some Integer Resource</Name>
                    <Operations>RW</Operations>
                    <MultipleInstances>Single</MultipleInstances>
                    <Mandatory>Mandatory</Mandatory>
                    <Type>Integer</Type>
                    <RangeEnumeration></RangeEnumeration>
                    <Units></Units>
                    <Description><![CDATA[Some description.]]></Description>
                </Item>
                <Item ID="2">
                    <Name>Some Boolean Multiple Resource</Name>
                    <Operations>RW</Operations>
                    <MultipleInstances>Multiple</MultipleInstances>
                    <Mandatory>Mandatory</Mandatory>
                    <Type>Boolean</Type>
                    <RangeEnumeration/>
                    <Units></Units>
                    <Description><![CDATA[Some description.]]></Description>
                </Item>
            </Resources>
            <Description2></Description2>
        </Object>
    </LWM2M>

for which, the generator outputs the following source:

.. code-block:: c

    /**
     * Generated by anjay_codegen.py on 2017-10-05 10:55:11
     *
     * LwM2M Object: Some Object Name
     * ID: 9999, URN: , Optional, Multiple
     *
     * This LwM2M Object reflects the state of buttons present on the touchscreen.
     */
    #include <assert.h>
    #include <stdbool.h>

    #include <anjay/anjay.h>
    #include <avsystem/commons/defs.h>
    #include <avsystem/commons/memory.h>
    #include <avsystem/commons/list.h>

    /**
     * Some String Resource: RW, Single, Mandatory
     * type: string, range: N/A, unit: N/A
     * Some description.
     */
    #define RID_SOME_STRING_RESOURCE 0

    /**
     * Some Integer Resource: RW, Single, Mandatory
     * type: integer, range: N/A, unit: N/A
     * Some description.
     */
    #define RID_SOME_INTEGER_RESOURCE 1

    /**
     * Some Boolean Multiple Resource: RW, Multiple, Mandatory
     * type: boolean, range: N/A, unit: N/A
     * Some description.
     */
    #define RID_SOME_BOOLEAN_MULTIPLE_RESOURCE 2

    typedef struct some_object_name_instance_struct {
        anjay_iid_t iid;

        // TODO: instance state
    } some_object_name_instance_t;

    typedef struct some_object_name_struct {
        const anjay_dm_object_def_t *def;
        AVS_LIST(some_object_name_instance_t) instances;

        // TODO: object state
    } some_object_name_t;

    static inline some_object_name_t *
    get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
        assert(obj_ptr);
        return AVS_CONTAINER_OF(obj_ptr, some_object_name_t, def);
    }

    static some_object_name_instance_t *
    find_instance(const some_object_name_t *obj,
                  anjay_iid_t iid) {
        AVS_LIST(some_object_name_instance_t) it;
        AVS_LIST_FOREACH(it, obj->instances) {
            if (it->iid == iid) {
                return it;
            } else if (it->iid > iid) {
                break;
            }
        }

        return NULL;
    }

    static int instance_present(anjay_t *anjay,
                                const anjay_dm_object_def_t *const *obj_ptr,
                                anjay_iid_t iid) {
        (void)anjay;
        return find_instance(get_obj(obj_ptr), iid) != NULL;
    }

    static int instance_it(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t *out,
                           void **cookie) {
        (void)anjay;

        AVS_LIST(some_object_name_instance_t) curr = (AVS_LIST(some_object_name_instance_t))*cookie;
        if (!curr) {
            curr = get_obj(obj_ptr)->instances;
        } else {
            curr = AVS_LIST_NEXT(curr);
        }

        *out = curr ? curr->iid : ANJAY_IID_INVALID;
        *cookie = curr;
        return 0;
    }

    static anjay_iid_t get_new_iid(AVS_LIST(some_object_name_instance_t) instances) {
        anjay_iid_t iid = 1;
        AVS_LIST(some_object_name_instance_t) it;
        AVS_LIST_FOREACH(it, instances) {
            if (it->iid == iid) {
                ++iid;
            } else if (it->iid > iid) {
                break;
            }
        }
        return iid;
    }

    static int init_instance(some_object_name_instance_t *inst,
                             anjay_iid_t iid) {
        assert(iid != ANJAY_IID_INVALID);

        inst->iid = iid;
        // TODO: instance init

        // TODO: return 0 on success, negative value on failure
        return 0;
    }

    static void release_instance(some_object_name_instance_t *inst) {
        // TODO: instance cleanup
        (void) inst;
    }

    static int instance_create(anjay_t *anjay,
                               const anjay_dm_object_def_t *const *obj_ptr,
                               anjay_iid_t *inout_iid,
                               anjay_ssid_t ssid) {
        (void) anjay; (void) ssid;
        some_object_name_t *obj = get_obj(obj_ptr);
        assert(obj);

        AVS_LIST(some_object_name_instance_t) created = AVS_LIST_NEW_ELEMENT(some_object_name_instance_t);
        if (!created) {
            return ANJAY_ERR_INTERNAL;
        }

        if (*inout_iid == ANJAY_IID_INVALID) {
            *inout_iid = get_new_iid(obj->instances);
        }

        int result = ANJAY_ERR_INTERNAL;
        if (*inout_iid == ANJAY_IID_INVALID
                || (result == init_instance(created, *inout_iid))) {
            AVS_LIST_CLEAR(&created);
            return result;
        }

        AVS_LIST(some_object_name_instance_t) *ptr;
        AVS_LIST_FOREACH_PTR(ptr, &obj->instances) {
            if ((*ptr)->iid > created->iid) {
                break;
            }
        }

        AVS_LIST_INSERT(ptr, created);
        return 0;
    }

    static int instance_remove(anjay_t *anjay,
                               const anjay_dm_object_def_t *const *obj_ptr,
                               anjay_iid_t iid) {
        (void)anjay;
        some_object_name_t *obj = get_obj(obj_ptr);
        assert(obj);

        AVS_LIST(some_object_name_instance_t) *it;
        AVS_LIST_FOREACH_PTR(it, &obj->instances) {
            if ((*it)->iid == iid) {
                release_instance(*it);
                AVS_LIST_DELETE(it);
                return 0;
            } else if ((*it)->iid > iid) {
                break;
            }
        }

        assert(0);
        return ANJAY_ERR_NOT_FOUND;
    }

    static int instance_reset(anjay_t *anjay,
                              const anjay_dm_object_def_t *const *obj_ptr,
                              anjay_iid_t iid) {
        (void) anjay;

        some_object_name_instance_t *inst = find_instance(get_obj(obj_ptr), iid);
        assert(inst);

        // TODO: instance reset
        return 0;
    }

    static int resource_read(anjay_t *anjay,
                             const anjay_dm_object_def_t *const *obj_ptr,
                             anjay_iid_t iid,
                             anjay_rid_t rid,
                             anjay_output_ctx_t *ctx) {
        (void)anjay;

        some_object_name_t *obj = get_obj(obj_ptr);
        assert(obj);
        some_object_name_instance_t *inst = find_instance(obj, iid);
        assert(inst);

        switch (rid) {
        case RID_SOME_STRING_RESOURCE:
            return anjay_ret_string(ctx, ""); // TODO

        case RID_SOME_INTEGER_RESOURCE:
            return anjay_ret_i32(ctx, 0); // TODO

        case RID_SOME_BOOLEAN_MULTIPLE_RESOURCE:
            {
                anjay_output_ctx_t *array = anjay_ret_array_start(ctx);
                int result = 0;
                if (!array
                        || (result = anjay_ret_array_index(array, 0))
                        || (result = anjay_ret_bool(array, 0))) {
                    return result ? result : ANJAY_ERR_INTERNAL;
                }
                return anjay_ret_array_finish(array);
            }

        default:
            return ANJAY_ERR_METHOD_NOT_ALLOWED;
        }
    }

    static int resource_write(anjay_t *anjay,
                              const anjay_dm_object_def_t *const *obj_ptr,
                              anjay_iid_t iid,
                              anjay_rid_t rid,
                              anjay_input_ctx_t *ctx) {
        (void)anjay;

        some_object_name_t *obj = get_obj(obj_ptr);
        assert(obj);
        some_object_name_instance_t *inst = find_instance(obj, iid);
        assert(inst);

        switch (rid) {
        case RID_SOME_STRING_RESOURCE:
            {
                char value[256]; // TODO
                return anjay_get_string(ctx, value, sizeof(value)); // TODO
            }

        case RID_SOME_INTEGER_RESOURCE:
            {
                int32_t value; // TODO
                return anjay_get_i32(ctx, &value); // TODO
            }

        case RID_SOME_BOOLEAN_MULTIPLE_RESOURCE:
            {
                anjay_input_ctx_t *array = anjay_get_array(ctx);
                if (!array) {
                    return ANJAY_ERR_INTERNAL;
                }

                anjay_riid_t riid;
                int result = 0;
                bool value; // TODO
                while (result && (result = anjay_get_array_index(array, &riid)) == 0) {
                    result = anjay_get_bool(ctx, &value); // TODO
                }

                return result;
            }

        default:
            return ANJAY_ERR_METHOD_NOT_ALLOWED;
        }
    }

    static int resource_dim(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid) {
        (void) anjay;

        some_object_name_t *obj = get_obj(obj_ptr);
        assert(obj);
        some_object_name_instance_t *inst = find_instance(obj, iid);
        assert(inst);

        switch (rid) {
        case RID_SOME_BOOLEAN_MULTIPLE_RESOURCE:
            return 1; // TODO

        default:
            return ANJAY_DM_DIM_INVALID;
        }
    }

    static const anjay_dm_object_def_t OBJ_DEF = {
        .oid = 9999,
        .supported_rids = ANJAY_DM_SUPPORTED_RIDS(
                    RID_SOME_STRING_RESOURCE,
                    RID_SOME_INTEGER_RESOURCE,
                    RID_SOME_BOOLEAN_MULTIPLE_RESOURCE,
                ),
        .handlers = {
            .instance_it = instance_it,
            .instance_present = instance_present,
            .instance_create = instance_create,
            .instance_remove = instance_remove,
            .instance_reset = instance_reset,

            .resource_present = anjay_dm_resource_present_TRUE,
            .resource_read = resource_read,
            .resource_write = resource_write,
            .resource_dim = resource_dim,

            // TODO: implement these if transactional write/create is required
            .transaction_begin = anjay_dm_transaction_NOOP,
            .transaction_validate = anjay_dm_transaction_NOOP,
            .transaction_commit = anjay_dm_transaction_NOOP,
            .transaction_rollback = anjay_dm_transaction_NOOP,
        }
    };

    const anjay_dm_object_def_t **some_object_name_object_create(void) {
        some_object_name_t *obj = (some_object_name_t *)
                avs_calloc(1, sizeof(some_object_name_t));
        if (!obj) {
            return NULL;
        }
        obj->def = &OBJ_DEF;

        // TODO: object init

        return &obj->def;
    }

    void some_object_name_object_release(const anjay_dm_object_def_t **def) {
        if (def) {
            some_object_name_t *obj = get_obj(def);
            AVS_LIST_CLEAR(&obj->instances) {
                release_instance(obj->instances);
            }

            // TODO: object cleanup

            avs_free(obj);
        }
    }

Now that the basic object structure is created, one can start thinking about filling in
missing parts marked in the code by the `TODO` comments. Then, to make the object present
in the LwM2M Data Model, one shall instantiate it, and finally :ref:`register <registering-objects>`
it within Anjay.
