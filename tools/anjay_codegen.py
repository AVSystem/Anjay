#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright 2017-2020 AVSystem <avsystem@avsystem.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import argparse
import collections
import textwrap
import operator
import sys
import re
from xml.etree import ElementTree
from xml.etree.ElementTree import Element
from typing import Mapping, Tuple, Optional
from jinja2 import Environment

C_TEMPLATE = """\
/**
 * Generated by anjay_codegen.py on {{ date_time }}
 *
 * LwM2M Object: {{ obj.name }}
 * ID: {{ obj.oid }}, URN: {{ obj.urn }}, {{ obj.mandatory_str }}, {{ obj.multiple_str }}
 *
 * {{ obj.description }}
 */
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
{% if obj.multiple %}
#include <avsystem/commons/avs_list.h>
{% endif %}
#include <avsystem/commons/avs_memory.h>

{% for res in obj.resources %}
/**
 * {{ res.name }}: {{ res.operations }}, {{ res.multiple_str }}, {{ res.mandatory_str }}
 * type: {{ res.type }}, range: {{ res.range_enumeration }}, unit: {{ res.units }}
{% if res.description %}
 * {{ res.description }}
{% endif %}
 */
#define {{ res.name_upper }} {{ res.rid }}

{% endfor %}
{% if obj.multiple %}
typedef struct {{ obj_inst_tag }} {
    anjay_iid_t iid;

    // TODO: instance state
} {{ obj_inst_type }};

{% endif %}
typedef struct {{ obj_repr_tag }} {
    const anjay_dm_object_def_t *def;
{% if obj.multiple %}
    AVS_LIST({{ obj_name_snake }}_instance_t) instances;
{% endif %}

    // TODO: object state
} {{ obj_repr_type }};

static inline {{ obj_repr_type }} *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, {{ obj_repr_type }}, def);
}

{% if obj.multiple %}
static {{ obj_inst_type }} *find_instance(const {{ obj_repr_type }} *obj,
{{ " " * (obj_inst_type|length + 22) }} anjay_iid_t iid) {
    AVS_LIST({{ obj_inst_type }}) it;
    AVS_LIST_FOREACH(it, obj->instances) {
        if (it->iid == iid) {
            return it;
        } else if (it->iid > iid) {
            break;
        }
    }

    return NULL;
}

static int list_instances(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_dm_list_ctx_t *ctx) {
    (void) anjay;

    AVS_LIST({{ obj_inst_type }}) it;
    AVS_LIST_FOREACH(it, get_obj(obj_ptr)->instances) {
        anjay_dm_emit(ctx, it->iid);
    }

    return 0;
}

static int init_instance({{ obj_inst_type }} *inst, anjay_iid_t iid) {
    assert(iid != ANJAY_ID_INVALID);

    inst->iid = iid;
    // TODO: instance init

    // TODO: return 0 on success, negative value on failure
    return 0;
}

static void release_instance({{ obj_inst_type }} *inst) {
    // TODO: instance cleanup
    (void) inst;
}

static {{ obj_inst_type }} *
add_instance({{ obj_repr_type }} *obj, anjay_iid_t iid) {
    assert(find_instance(obj, iid) == NULL);

    AVS_LIST({{ obj_inst_type }}) created =
            AVS_LIST_NEW_ELEMENT({{ obj_inst_type }});
    if (!created) {
        return NULL;
    }

    int result = init_instance(created, iid);
    if (result) {
        AVS_LIST_CLEAR(&created);
        return NULL;
    }

    AVS_LIST({{ obj_inst_type }}) *ptr;
    AVS_LIST_FOREACH_PTR(ptr, &obj->instances) {
        if ((*ptr)->iid > created->iid) {
            break;
        }
    }

    AVS_LIST_INSERT(ptr, created);
    return created;
}

static int instance_create(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t iid) {
    (void) anjay;
    {{ obj_repr_type }} *obj = get_obj(obj_ptr);
    assert(obj);

    return add_instance(obj, iid) ? 0 : ANJAY_ERR_INTERNAL;
}

static int instance_remove(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t iid) {
    (void) anjay;
    {{ obj_repr_type }} *obj = get_obj(obj_ptr);
    assert(obj);

    AVS_LIST({{ obj_inst_type }}) *it;
    AVS_LIST_FOREACH_PTR(it, &obj->instances) {
        if ((*it)->iid == iid) {
            release_instance(*it);
            AVS_LIST_DELETE(it);
            return 0;
        } else if ((*it)->iid > iid) {
            break;
        }
    }

    assert(0);
    return ANJAY_ERR_NOT_FOUND;
}

{% endif %}
{% if obj.needs_instance_reset_handler %}
static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;

    {{ obj_repr_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    // TODO: instance reset
    return 0;
}

{% endif %}
static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

{% for res in obj.resources %}
    anjay_dm_emit_res(ctx, {{ res.name_upper }},
                      {{ res.kind_enum }}, ANJAY_DM_RES_PRESENT);
{% endfor %}
    return 0;
}

{% if obj.has_any_readable_resources %}
static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;

    {{ obj_repr_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if 'R' in res.operations %}
    case {{ res.name_upper }}:{{ res.read_handler|indent(4) }}

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
{% if obj.has_any_writable_resources %}
static int resource_write(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_rid_t rid,
                          anjay_riid_t riid,
                          anjay_input_ctx_t *ctx) {
    (void) anjay;

    {{ obj_repr_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if 'W' in res.operations %}
    case {{ res.name_upper }}:{{ res.write_handler|indent(4) }}

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
{% if obj.has_any_executable_resources %}
static int resource_execute(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_execute_ctx_t *arg_ctx) {
    (void) arg_ctx;

    {{ obj_repr_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if 'E' in res.operations %}
    case {{ res.name_upper }}:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
{% if obj.has_any_multiple_writable_resources %}
static int resource_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_rid_t rid) {
    (void) anjay;

    {{ obj_repr_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if res.multiple and 'W' in res.operations %}
    case {{ res.name_upper }}:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO: remove all Resource Instances

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
{% if obj.has_any_multiple_resources %}
static int list_resource_instances(anjay_t *anjay,
                                   const anjay_dm_object_def_t *const *obj_ptr,
                                   anjay_iid_t iid,
                                   anjay_rid_t rid,
                                   anjay_dm_list_ctx_t *ctx) {
    (void) anjay;

    {{ obj_repr_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if res.multiple %}
    case {{ res.name_upper }}:
        // anjay_dm_emit(ctx, ...); // TODO
        return 0;

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = {{ obj.oid }},
    .handlers = {
{% for handler in handlers %}
{% if handler is string %}
{{ '' if handler == '' else '        ' + handler }}
{% else %}
        {{ '.%s = %s' % handler }}{{ "" if loop.last else "," }}
{% endif %}
{% endfor %}
    }
};

const anjay_dm_object_def_t **{{ obj_name_snake }}_object_create(void) {
    {{ obj_repr_type }} *obj = ({{ obj_repr_type }} *) avs_calloc(1, sizeof({{ obj_repr_type }}));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    // TODO: object init

    return &obj->def;
}

void {{ obj_name_snake }}_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        {{ obj_repr_type }} *obj = get_obj(def);
{% if obj.multiple %}
        AVS_LIST_CLEAR(&obj->instances) {
            release_instance(obj->instances);
        }
{% endif %}

        // TODO: object cleanup

        avs_free(obj);
    }
}
"""

CXX_TEMPLATE = """\
/**
 * Generated by anjay_codegen.py on {{ date_time }}
 *
 * LwM2M Object: {{ obj.name }}
 * ID: {{ obj.oid }}, URN: {{ obj.urn }}, {{ obj.mandatory_str }}, {{ obj.multiple_str }}
 *
 * {{ obj.description }}
 */
#include <algorithm>
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
{% if obj.multiple %}
#include <avsystem/commons/avs_list_cxx.hpp>
{% endif %}

using namespace std;

namespace {

{% for res in obj.resources %}
/**
 * {{ res.name }}: {{ res.operations }}, {{ res.multiple_str }}, {{ res.mandatory_str }}
 * type: {{ res.type }}, range: {{ res.range_enumeration }}, unit: {{ res.units }}
{% if res.description %}
 * {{ res.description }}
{% endif %}
 */
constexpr anjay_rid_t {{ res.name_upper }} = {{ res.rid }};

{% endfor %}
{% if obj.multiple %}
struct {{ obj_inst_cxx_type }} {
    const anjay_iid_t iid;
    // TODO: instance state

    explicit {{ obj_inst_cxx_type }}(anjay_iid_t assigned_iid) : iid(assigned_iid) {
        // TODO: instance init
    }

    ~{{ obj_inst_cxx_type }}() {
        // TODO: instance cleanup
    }

    {{ obj_inst_cxx_type }}(const {{ obj_inst_cxx_type }} &) = delete;
    {{ obj_inst_cxx_type }} &operator=(const {{ obj_inst_cxx_type }} &) = delete;
};

{% endif %}
struct {{ obj_cxx_type }} {
    const anjay_dm_object_def_t *const def;
{% if obj.multiple %}
    avs::List<{{ obj_inst_cxx_type }}> instances;
{% endif %}
    // TODO: object state

    {{ obj_cxx_type }}();
    ~{{ obj_cxx_type }}();
    {{ obj_cxx_type }}(const {{ obj_cxx_type }} &) = delete;
    {{ obj_cxx_type }} &operator=(const {{ obj_cxx_type }} &) = delete;
};

inline {{ obj_cxx_type }} *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    static const {{ obj_cxx_type }} *const FAKE_OBJECT_PTR = nullptr;
    static const auto DEF_PTR_OFFSET =
            intptr_t(reinterpret_cast<const char *>(&FAKE_OBJECT_PTR[1].def)
                     - reinterpret_cast<const char *>(&FAKE_OBJECT_PTR[1]));
    return reinterpret_cast<{{ obj_cxx_type }} *>(intptr_t(obj_ptr) - DEF_PTR_OFFSET);
}

{% if obj.multiple %}
{{ obj_inst_cxx_type }} *find_instance({{ obj_cxx_type }} *obj,
{{ " " * (obj_inst_cxx_type|length + 15) }} anjay_iid_t iid) {
    for ({{ obj_inst_cxx_type }} &instance : obj->instances) {
        if (instance.iid == iid) {
            return &instance;
        } else if (instance.iid > iid) {
            break;
        }
    }

    return nullptr;
}

int list_instances(anjay_t *,
                   const anjay_dm_object_def_t *const *obj_ptr,
                   anjay_dm_list_ctx_t *ctx) {
    for (const {{ obj_inst_cxx_type }} &instance : get_obj(obj_ptr)->instances) {
        anjay_dm_emit(ctx, instance.iid);
    }

    return 0;
}

{{ obj_inst_cxx_type }} *
add_instance({{ obj_cxx_type }} *obj, anjay_iid_t iid) {
    auto insert_it = std::find_if(obj->instances.begin(), obj->instances.end(),
                                  [iid](const {{ obj_inst_cxx_type }} &inst) {
                                      return inst.iid >= iid;
                                  });
    assert(insert_it == obj->instances.end() || insert_it->iid != iid);
    auto instance_it = obj->instances.emplace(insert_it, iid);
    if (instance_it == obj->instances.end()) {
        return NULL;
    }
    return &(*instance_it);
}

int instance_create(anjay_t *,
                    const anjay_dm_object_def_t *const *obj_ptr,
                    anjay_iid_t iid) {
    {{ obj_cxx_type }} *obj = get_obj(obj_ptr);
    assert(obj);

    return add_instance(obj, iid) ? 0 : ANJAY_ERR_INTERNAL;
}

int instance_remove(anjay_t *,
                    const anjay_dm_object_def_t *const *obj_ptr,
                    anjay_iid_t iid) {
    {{ obj_cxx_type }} *obj = get_obj(obj_ptr);
    assert(obj);

    auto erase_it = std::find_if(obj->instances.begin(), obj->instances.end(),
                                 [iid](const {{ obj_inst_cxx_type }} &inst) {
                                     return inst.iid == iid;
                                 });
    assert(erase_it != obj->instances.end());
    obj->instances.erase(erase_it);
    return 0;
}

{% endif %}
{% if obj.needs_instance_reset_handler %}
int instance_reset(anjay_t *,
                   const anjay_dm_object_def_t *const *obj_ptr,
                   anjay_iid_t iid) {
    {{ obj_cxx_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_cxx_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    // TODO: instance reset
    return 0;
}

{% endif %}
int list_resources(anjay_t *,
                   const anjay_dm_object_def_t *const *,
                   anjay_iid_t,
                   anjay_dm_resource_list_ctx_t *ctx) {
{% for res in obj.resources %}
    anjay_dm_emit_res(ctx, {{ res.name_upper }},
                      {{ res.kind_enum }}, ANJAY_DM_RES_PRESENT);
{% endfor %}
    return 0;
}

{% if obj.has_any_readable_resources %}
int resource_read(anjay_t *,
                  const anjay_dm_object_def_t *const *obj_ptr,
                  anjay_iid_t iid,
                  anjay_rid_t rid,
                  anjay_riid_t riid,
                  anjay_output_ctx_t *ctx) {
    {{ obj_cxx_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_cxx_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if 'R' in res.operations %}
    case {{ res.name_upper }}:{{ res.read_handler|indent(4) }}

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
{% if obj.has_any_writable_resources %}
int resource_write(anjay_t *,
                   const anjay_dm_object_def_t *const *obj_ptr,
                   anjay_iid_t iid,
                   anjay_rid_t rid,
                   anjay_riid_t riid,
                   anjay_input_ctx_t *ctx) {
    {{ obj_cxx_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_cxx_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if 'W' in res.operations %}
    case {{ res.name_upper }}:{{ res.write_handler|indent(4) }}

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
{% if obj.has_any_executable_resources %}
int resource_execute(anjay_t *,
                     const anjay_dm_object_def_t *const *obj_ptr,
                     anjay_iid_t iid,
                     anjay_rid_t rid,
                     anjay_execute_ctx_t *) {
    {{ obj_cxx_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_cxx_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if 'E' in res.operations %}
    case {{ res.name_upper }}:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
{% if obj.has_any_multiple_writable_resources %}
int resource_reset(anjay_t *,
                   const anjay_dm_object_def_t *const *obj_ptr,
                   anjay_iid_t iid,
                   anjay_rid_t rid) {
    {{ obj_cxx_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_cxx_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if res.multiple and 'W' in res.operations %}
    case {{ res.name_upper }}:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO: remove all Resource Instances

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
{% if obj.has_any_multiple_resources %}
int list_resource_instances(anjay_t *,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_dm_list_ctx_t *ctx) {
    {{ obj_cxx_type }} *obj = get_obj(obj_ptr);
    assert(obj);
{% if obj.multiple %}
    {{ obj_inst_cxx_type }} *inst = find_instance(obj, iid);
    assert(inst);
{% else %}
    assert(iid == 0);
{% endif %}

    switch (rid) {
{% for res in obj.resources %}
{% if res.multiple %}
    case {{ res.name_upper }}:
        // anjay_dm_emit(ctx, ...); // TODO
        return 0;

{% endif %}
{% endfor %}
    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

{% endif %}
struct ObjDef : public anjay_dm_object_def_t {
    ObjDef() : anjay_dm_object_def_t() {
        oid = {{ obj.oid }};

{% for handler in handlers %}
{% if handler is string %}
{{ '' if handler == '' else '        ' + handler }}
{% else %}
        {{ 'handlers.%s = %s;' % handler }}
{% endif %}
{% endfor %}
    }
} const OBJ_DEF;

{{ obj_cxx_type }}::{{ obj_cxx_type }}() : def(&OBJ_DEF) {
    // TODO: object init
}

{{ obj_cxx_type }}::~{{ obj_cxx_type }}() {
    // TODO: object cleanup
}

} // namespace

const anjay_dm_object_def_t **{{ obj_name_snake }}_object_create(void) {
    {{ obj_cxx_type }} *obj = new (nothrow) {{ obj_cxx_type }};
    if (!obj) {
        return NULL;
    }
    return const_cast<const anjay_dm_object_def_t **>(&obj->def);
}

void {{ obj_name_snake }}_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        delete get_obj(def);
    }
}
"""


def _node_text(n: Element) -> str:
    return (n.text if n.text is not None else '').strip()


def _sanitize_macro_name(n: str) -> str:
    return re.sub(r'[^a-zA-Z0-9]+', '_', n).strip('_')


class ResourceDef(collections.namedtuple('ResourceDef', ['rid', 'name', 'operations', 'multiple', 'mandatory', 'type',
                                                         'range_enumeration', 'units', 'description'])):
    @property
    def mandatory_str(self) -> str:
        return 'Mandatory' if self.mandatory else 'Optional'

    @property
    def multiple_str(self):
        return 'Multiple' if self.multiple else 'Single'

    @property
    def name_upper(self) -> str:
        return _sanitize_macro_name('RID_' + self.name.upper())

    @property
    def kind_enum(self) -> str:
        if self.operations not in {'R', 'W', 'RW', 'E', 'BS_RW'}:
            raise AssertionError('unexpected operations: ' + self.operations)
        result = 'ANJAY_DM_RES_' + self.operations
        if self.multiple:
            if 'E' in self.operations:
                raise AssertionError('multiple-instance executable resources are not supported')
            result += 'M'
        return result

    @property
    def read_handler(self) -> Optional[str]:
        assert 'R' in self.operations

        types = [
            (('boolean', 'bool'), 'anjay_ret_bool(%s, 0)'),
            (('integer', 'int'),  'anjay_ret_i32(%s, 0)'),
            (('float',),          'anjay_ret_float(%s, 0)'),
            (('corelnk', # TODO T2033
              'string', 'str'),   'anjay_ret_string(%s, "")'),
            (('opaque',),         'anjay_ret_bytes(%s, "", 0)'),
            (('time',),           'anjay_ret_i64(%s, 0)'),
            (('objlnk',),         'anjay_ret_objlnk(%s, 0, 0)'),
            (('unsigned integer',
              'unsigned int',
              'unsigned'),        'anjay_ret_u32(%s, 0)')
        ]

        def get_ret_func(type):
            for match_types, ret_func in types:
                if type in match_types:
                    return ret_func
            else:
                raise AssertionError('unexpected type: ' + type)

        if not self.multiple:
            return textwrap.indent(textwrap.dedent("""
                    assert(riid == ANJAY_ID_INVALID);
                    return %s; // TODO"""), '    ') % (get_ret_func(self.type) % ('ctx',))
        else:
            return textwrap.indent(textwrap.dedent("""
                    // TODO: extract Resource Instance
                    return %s; // TODO"""), '    ') % (get_ret_func(self.type) % ('ctx',))


    @property
    def write_handler(self) -> Optional[Tuple[str, str]]:
        assert 'W' in self.operations

        types = [
            (('boolean', 'bool'), 'bool value',      'anjay_get_bool(%s, &value)'),
            (('integer', 'int'),  'int32_t value',   'anjay_get_i32(%s, &value)'),
            (('float',),          'float value',     'anjay_get_float(%s, &value)'),
            (('corelnk', # TODO T2033
              'string', 'str'),   'char value[256]', 'anjay_get_string(%s, value, sizeof(value))'),
            (('opaque',),
                 'uint8_t value[256];\n'
                 '    bool finished;\n'
                 '    size_t bytes_read',
                 'anjay_get_bytes(%s,\n'
                 '                           &bytes_read,\n'
                 '                           &finished,\n'
                 '                           value,\n'
                 '                           sizeof(value))'),
            (('time',),           'int64_t value',   'anjay_get_i64(%s, &value)'),
            (('objlnk',),
                'anjay_oid_t objlnk_oid;\n'
                '    anjay_iid_t objlnk_iid',
                'anjay_get_objlnk(%s, &objlnk_oid, &objlnk_iid)'),
            (('unsigned integer',
              'unsigned int',
              'unsigned'),        'uint32_t value',  'anjay_get_u32(%s, &value)')
        ]

        def get_get_func(type):
            for match_types, alloc_value, get_func in types:
                if type in match_types:
                    return alloc_value, get_func
            else:
                raise AssertionError('unexpected type: ' + type)

        local_def, get_func = get_get_func(self.type.lower())
        get_func %= ('ctx',)
        if not self.multiple:
            return ' ' + textwrap.dedent("""\
                    {
                        assert(riid == ANJAY_ID_INVALID);
                        %s; // TODO
                        return %s; // TODO
                    }""") % (local_def, get_func)
        else:
            return ' ' + textwrap.dedent("""\
                    {
                        // TODO: extract Resource Instance
                        %s; // TODO
                        return %s; // TODO
                    }""") % (local_def, get_func)

    @classmethod
    def from_etree(cls, res: Element) -> 'ResourceDef':
        return cls(rid=int(res.get('ID')),
                   name=_node_text(res.find('Name')),
                   operations=_node_text(res.find('Operations')).upper()
                       or 'BS_RW', # no operations = resource modifiable by Bootstrap Server
                   multiple={'Single': False, 'Multiple': True}[_node_text(res.find('MultipleInstances'))],
                   mandatory={'Optional': False, 'Mandatory': True}[_node_text(res.find('Mandatory'))],
                   type=(_node_text(res.find('Type')).lower() or 'N/A'),
                   range_enumeration=(_node_text(res.find('RangeEnumeration')) or 'N/A'),
                   units=(_node_text(res.find('Units')) or 'N/A'),
                   description=textwrap.fill(_node_text(res.find('Description'))).replace('\n', '\n * '))


class ObjectDef(collections.namedtuple('ObjectDef',
                                       ['oid', 'name', 'description', 'urn', 'multiple', 'mandatory', 'resources'])):
    @property
    def name_snake(self) -> str:
        return self.name.lower().replace(' ', '_')

    @property
    def name_pascal(self) -> str:
        return ''.join(word.capitalize() for word in self.name.split())

    @property
    def mandatory_str(self) -> str:
        return 'Mandatory' if self.mandatory else 'Optional'

    @property
    def multiple_str(self):
        return 'Multiple' if self.multiple else 'Single'

    @property
    def has_any_readable_resources(self) -> bool:
        return any('R' in res.operations for res in self.resources)

    @property
    def has_any_writable_resources(self) -> bool:
        return any('W' in res.operations for res in self.resources)

    @property
    def has_any_executable_resources(self) -> bool:
        return any('E' in res.operations for res in self.resources)

    @property
    def has_any_multiple_resources(self) -> bool:
        return any(res.multiple for res in self.resources)

    @property
    def has_any_multiple_writable_resources(self) -> bool:
        return any((res.multiple and 'W' in res.operations) for res in self.resources)

    @property
    def needs_instance_reset_handler(self) -> bool:
        return self.multiple or self.has_any_writable_resources

    @staticmethod
    def parse_resources(obj: ElementTree):
        return sorted([ResourceDef.from_etree(item) for item in obj.find('Resources').findall('Item')],
                       key=operator.attrgetter('rid'))

    @classmethod
    def from_etree(cls, obj: ElementTree, resources_subset: set) -> 'ObjectDef':
        resources = ObjectDef.parse_resources(obj)
        if resources_subset is not None:
            resources = [ r for r in resources if r.rid in resources_subset ]

        return cls(name=_node_text(obj.find('Name')),
                   description=textwrap.fill(_node_text(obj.find('Description1'))).replace('\n', '\n * '),
                   oid=int(_node_text(obj.find('ObjectID'))),
                   urn=_node_text(obj.find('ObjectURN')),
                   multiple={'Single': False, 'Multiple': True}[_node_text(obj.find('MultipleInstances'))],
                   mandatory={'Optional': False, 'Mandatory': True}[_node_text(obj.find('Mandatory'))],
                   resources=resources)


def generate_object_boilerplate(obj_tree: ElementTree, cxx: bool, resources_subset: set = None):
    obj = ObjectDef.from_etree(obj_tree, resources_subset)

    jinja_env = Environment(trim_blocks=True)

    handlers = []
    if obj.multiple:
        handlers.append(('list_instances', 'list_instances'))
        handlers.append(('instance_create', 'instance_create'))
        handlers.append(('instance_remove', 'instance_remove'))
    else:
        handlers.append(('list_instances', 'anjay_dm_list_instances_SINGLE'))

    if obj.needs_instance_reset_handler:
        handlers.append(('instance_reset', 'instance_reset'))

    handlers.append('')
    handlers.append(('list_resources', 'list_resources'))
    if obj.has_any_readable_resources:
        handlers.append(('resource_read', 'resource_read'))
    if obj.has_any_writable_resources:
        handlers.append(('resource_write', 'resource_write'))
    if obj.has_any_executable_resources:
        handlers.append(('resource_execute', 'resource_execute'))
    if obj.has_any_multiple_writable_resources:
        handlers.append(('resource_reset', 'resource_reset'))
    if obj.has_any_multiple_resources:
        handlers.append(('list_resource_instances', 'list_resource_instances'))

    handlers.append('')
    handlers.append('// TODO: implement these if transactional write/create is required')
    handlers.append(('transaction_begin', 'anjay_dm_transaction_NOOP'))
    handlers.append(('transaction_validate', 'anjay_dm_transaction_NOOP'))
    handlers.append(('transaction_commit', 'anjay_dm_transaction_NOOP'))
    handlers.append(('transaction_rollback', 'anjay_dm_transaction_NOOP'))

    return (jinja_env.from_string(CXX_TEMPLATE if cxx else C_TEMPLATE)
                .render(obj=obj,
                        handlers=handlers,
                        date_time=datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        obj_name_snake=obj.name_snake,
                        obj_repr_tag=obj.name_snake + '_object_struct',
                        obj_repr_type=obj.name_snake + '_object_t',
                        obj_inst_tag=obj.name_snake + '_instance_struct',
                        obj_inst_type=obj.name_snake + '_instance_t',
                        obj_cxx_type=obj.name_pascal + 'Object',
                        obj_inst_cxx_type=obj.name_pascal + 'Instance'))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Parses an LwM2M object definition XML and generates Anjay object skeleton')
    parser.add_argument('-i', '--input', help='Input filename or - to read from stdin')
    parser.add_argument('-o', '--output', default='/dev/stdout', help='Output filename (default: stdout)')
    parser.add_argument('-x', '--c++', dest='cxx', action='store_true', help='Generate C++ code (default: C)')
    parser.add_argument('-l', '--list', help='List resources and their names only', action='store_true')
    parser.add_argument('-r', '--resources', nargs='+', type=int, help='Generate code only for a specific list of resources. If the resource does not exist it is silently ignored.')

    args = parser.parse_args()
    if args.input == '-':
        args.input = '/dev/stdin'
    if args.output == '-':
        args.output = '/dev/stdout'

    if args.input is None:
        parser.print_usage()
        sys.exit(1)

    with open(args.input) as f:
        tree = ElementTree.fromstring(f.read())
        obj = tree.find('Object')
        if args.list:
            for r in ObjectDef.parse_resources(obj):
                print(r.rid, r.name, '(mandatory)' if r.mandatory else '')
            sys.exit(0)

        boilerplate = generate_object_boilerplate(obj, args.cxx, args.resources)

    with open(args.output, 'w') as f:
        print(boilerplate, file=f)
